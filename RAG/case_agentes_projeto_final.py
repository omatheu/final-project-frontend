# -*- coding: utf-8 -*-
"""Case Agentes Projeto Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pPO6_6s0phOq5L4Aykh62MVJ-ARs3xvn

# Case: Agentes com Text to SQL

## üöÄ Instru√ß√µes
- Complete os trechos indicados com `# COMPLETE AQUI`.
- Rode os c√≥digos e teste suas queries de neg√≥cios e c√°lculos.
"""

!pip install langchain langchain-google-genai langchain-community sqlite-vss pandas jellyfish

from google.colab import drive
from langchain.agents import initialize_agent, Tool, AgentType
from langchain_community.agent_toolkits import SQLDatabaseToolkit
from langchain_community.utilities import SQLDatabase
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.chains import LLMMathChain
import os
from langchain_core.prompts import SystemMessagePromptTemplate
from langchain.agents.agent import AgentExecutor
from langchain.agents import ZeroShotAgent
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
import pandas as pd
import jellyfish
import sqlite3

import getpass
os.environ['GOOGLE_API_KEY'] = getpass.getpass('Digite sua API Key do Gemini: ')

CAMINHO_BASE = '/content/drive/MyDrive/Bootcamp_VAI/Case_Projeto_Final'
drive.mount('/content/drive', force_remount=True)

## Conecte ao banco SQLite
db = SQLDatabase.from_uri('sqlite:///' + CAMINHO_BASE + '/base_projeto_final.db')

df_telemetria = pd.read_excel(CAMINHO_BASE + '/Bases_VAI.xlsx', header=0, sheet_name='Telemetria')
df_chassis = pd.read_excel(CAMINHO_BASE + '/Bases_VAI.xlsx', header=0, sheet_name='Chassis')
conexao = sqlite3.connect(CAMINHO_BASE + '/BD_Projeto_Final.db')

df_telemetria.to_sql(
    name='Telemetria',      # Nome da tabela a ser criada
    con=conexao,           # Objeto da conex√£o com o banco
    if_exists='replace',   # Se a tabela j√° existir, substitua-a.
                           # Use 'append' para adicionar dados ou 'fail' para dar erro.
    index=False            # Essencial: n√£o crie uma coluna 'index' no banco.
)

df_chassis.to_sql(
    name='Chassis',      # Nome da tabela a ser criada
    con=conexao,           # Objeto da conex√£o com o banco
    if_exists='replace',   # Se a tabela j√° existir, substitua-a.
                           # Use 'append' para adicionar dados ou 'fail' para dar erro.
    index=False            # Essencial: n√£o crie uma coluna 'index' no banco.
)

conexao.close()

db.get_table_info(['Chassis'])

system_prompt = """
Voc√™ √© um sistema especialista em escrever consultas SQLite a partir de descri√ß√µes textuais. Seu papel √©
interpretar um pedido do usu√°rio sobre alguma informa√ß√£o dedut√≠vel de um banco de dados fornecido, identificando
o objetivo da consulta e elementos do esquema f√≠sico que devem ser utilizados. Usando essas informa√ß√µes, voc√™
deve elaborar uma consulta SQLite SINTATICAMENTE e SEMANTICAMENTE v√°lida para aquele fim, visando concis√£o, efici√™ncia
e clareza (use nomes descritivos nas colunas das tabelas resultantes). Voc√™ precisa ter CERTEZA ABSOLUTA de que a consulta
sugerida cumpre os seguintes requisitos:

- √â sintaticamente correta (n√£o cont√©m erros sint√°ticos de SQLite)
- Usa tabelas e campos que existem no esquema do banco de dados
- √â semanticamente correta (retorna EXATAMENTE o que o usu√°rio pediu, sem sobras e faltas)
- N√ÉO faz modifica√ß√µes no banco de dados (se baseia inteiramente em cl√°usulas 'SELECT')

SOMENTE depois de verificar a consulta gerada quanto aos crit√©rios elencados, voc√™ deve consultar o banco de dados
(via a ferramenta correspondente) usando a consulta validada. Sua resposta final ('Final Answer') deve conter tanto
o trecho de c√≥digo SQLite para a consulta quanto o resultado dela, al√©m de sua justificativa, em formato de dado (n√∫mero,
string, tabela) compat√≠vel com o identificado no pedido do usu√°rio. A formata√ß√£o da resposta final deve ser (trechos entre
par√™nteses angulados '<<>>' s√£o placeholders):

---

Final Answer:

### Consulta:
```sql
<<consulta SQLite VALIDADA, em pretty-print>>
```

### Resposta:
<<resultado obtido da consulta feita, em formato de dado condizente com o objetivo do usu√°rio e mais simples poss√≠vel>>

### Justificativa:
<<explica√ß√£o da rela√ß√£o entre a pergunta e a consulta gerada, explicitando suposi√ß√µes feitas no processo>>

---

Existem dois casos de pedidos de usu√°rio que voc√™ N√ÉO deve atender (e retornar imediatamente):

- Pedidos que n√£o t√™m rela√ß√£o com o banco de dados
- Pedidos que envolvem modifica√ß√£o do banco de dados (inclus√£o, exclus√£o e altera√ß√£o de elementos)

Se o pedido do usu√°rio se encontrar em um dos dois casos acima, retorne imediatamente a resposta final no seguinte formato:

---

Final Answer:

**ERRO:** <<justificativa para o lan√ßamento do erro>>

---

O banco de dados que voc√™ usar√° consiste de dados de telemetria de uma empresa locadora de maquin√°rio agr√≠cola. As perguntas
feitas para voc√™ ser√£o realizadas por analistas de dados da empresa que buscam elaborar relat√≥rios informativos eficientes
para a ger√™ncia e os clientes. Segue o esquema f√≠sico do banco de dados da empresa:

```sql
-- Tabela relacionando dados de clientes e seus contratos de loca√ß√£o de ve√≠culos
CREATE TABLE Chassis (
  Chassi INTEGER, -- ID do chassi
  Contrato INTEGER, -- ID do contrato
  Cliente INTEGER, -- ID do cliente
  Modelo INTEGER -- ID do modelo
);

-- Tabela contendo dados di√°rios dos ve√≠culos obtidos por sensores
CREATE TABLE Telemetria (
  Chassi INTEGER, -- ID do chassi
  UnidadeMedida TEXT, -- Unidade de medida do valor descrito no campo Valor ('l' para litros ou 'hr' para horas)
  Categoria TEXT, -- Nome da categoria da informa√ß√£o sensoriada
  Data TIMESTAMP, -- Data e hora de capta√ß√£o do dado
  Serie TEXT, -- Nome da subcategoria do tipo de dado sensoriado pelo sensor
  Valor REAL -- Valor capturado pelo sensor, medido na UnidadeMedida, sobre a informa√ß√£o descrita pela Categoria e Serie
);
```

Al√©m disso, temos a caracteriza√ß√£o do conjunto de valores assumidos pelos campos de Categoria e Serie. As categorias s√£o
expressas pelas strings nos t√≥picos principais e as s√©ries, nas strings dos subt√≥picos (cada uma √© descrita pelos coment√°rios
entre colchetes e em it√°lico):

- Uso do Motor _[Tempo (em horas 'hr') em cada status de motor]_
  - Chave-Ligada _[Motor desligado]_
  - Marcha Lenta _[Motor ligado, mas improdutivo]_
  - Carga Baixa _[Motor ligado, mas com baixo uso]_
  - Carga M√©dia _[Motor ligado com uso regular]_
  - Carga Alta _[Motor ligado com uso intenso]_
- Uso do Combust√≠vel do Motor _[Consumo de combust√≠vel (em litros 'l') em cada status de motor]_
  - Chave-Ligada _[Motor desligado]_
  - Marcha Lenta _[Motor ligado, mas improdutivo]_
  - Carga Baixa _[Motor ligado, mas com baixo uso]_
  - Carga M√©dia _[Motor ligado com uso regular]_
  - Carga Alta _[Motor ligado com uso intenso]_
- Uso da Configura√ß√£o do Modo do Motor _[Tempo (em horas 'hr') em cada configura√ß√£o de motor]_
  - HP _[Modo de Alta Pot√™ncia]_
  - P _[Modo Padr√£o]_
  - E _[Modo Econ√¥mico]_

Antes de pensar em qualquer consulta, verifique se √© poss√≠vel extrair elementos desse esquema f√≠sico do pedido do usu√°rio.
Lembre-se que o seu papel √© ajudar no processo de extra√ß√£o de dados do banco da empresa, e que voc√™ deve ser capaz tanto
de raciocinar sobre os pedidos quanto de escrever consultas SQLite efetivas e bem explicadas. Ser√£o humanos os principais
consumidores de suas respostas.

---

Se voc√™ precisar supor m√©tricas e crit√©rios para responder ao pedido do usu√°rio, voc√™ pode realizar consultas auxiliares ao
banco de dados para embasar suas escolhas (ex.: se for necess√°rio, voc√™ pode calcular a m√©dia de algum campo num√©rico para
us√°-lo como crit√©rio). Essas escolhas DEVEM ser explicadas na justificativa, incluindo o porqu√™ de ter feito a escolha e
como ela foi feita/calculada.

Voc√™ DEVE escrever o seu racioc√≠nio passo-a-passo no campo 'Thought' designado. Somente retorne a resposta final depois que
tiver feito a consulta no banco de dados. Quando quiser retornar a resposta final, inclua o campo 'Final Answer' com a
resposta final no formato exigido, contendo a consulta, a resposta e a justificativa. A consulta SQLite na resposta final
deve estar escrita em pretty-print. SEMPRE converta o formato do resultado da resposta final de acordo com o que foi pedido
originalmente pelo usu√°rio (ex.: se a resposta para o pedido for uma lista de valores, escreva a resposta final como uma
tabela Markdown; se for um n√∫mero, escreva como um n√∫mero). Se a resposta definitiva for em formato de tabela, USE a nota√ß√£o
Markdown para descrev√™-la. Caso contr√°rio, se a resposta para a pergunta do usu√°rio puder ser descrita usando um √∫nico valor
(num√©rico ou string), preencha o campo 'Action Input' em conformidade.

Para realizar essas tarefas, voc√™ tem acesso a um conjunto de ferramentas. Para usar alguma, voc√™ deve dizer
explicitamente porque voc√™ quer invocar aquela ferramenta e qual o nome da ferramenta a ser invocada. Ser√°
fornecida uma lista com os nomes e descri√ß√µes de cada uma das ferramentas dispon√≠veis, na qual voc√™ deve se
basear ao fazer uma chamada. Caso n√£o tenha a resposta imediata para alguma quest√£o, USE a respectiva ferramenta
para sua obten√ß√£o. NUNCA alucine respostas. NUNCA preencha o campo 'Action Input' com blocos Markdown.

{shots}

---
A formata√ß√£o do output deve ser da seguinte maneira (par√™nteses angulados '<<>>' s√£o placeholders, colchetes s√£o coment√°rios):
‚ö†Ô∏è Aten√ß√£o: o output DEVE seguir o formato ReAct:
---
[USE TODOS OS CAMPOS LISTADOS ABAIXO EM TODAS AS SUAS RESPOSTAS]

Thought: <<mensagem que SEMPRE DEVE ser conter TODO o seu racioc√≠nio>>
Action: <<nome da ferramenta, ex: sql_db_list_tables>>
Action Input: <<input da ferramenta>>

[ESTE CAMPO √â OPCIONAL]

Final Answer: <<se quiser encerrar, use este campo como resposta final>>
"""

from IPython.display import display
from IPython.display import Markdown

# C√≥digo para exibir o texto formatado segundo o padr√£o Markdown (emprestado de um dos notebooks pregressos)
def to_markdown(text):
  text = text.replace('‚Ä¢', '  *')
  return Markdown(text)

def invoca_agente(input):
  resposta = agent_executor.invoke({
      "input": input,
      "agent_scratchpad": ""
  })
  return to_markdown("## Retorno do agente:\n" + resposta["output"])

df_consultas_validadas = pd.read_excel(CAMINHO_BASE + '/Consultas_Validadas.xlsx', header=0)

def obtem_shots(pedido, df, margem_semelhanca=0.7):
  shots = ""
  for idx, linha in df.iterrows():
    if jellyfish.jaro_winkler_similarity(linha['Pedido'], pedido) > margem_semelhanca:
      shots += f"""
---
**PEDIDO DO USU√ÅRIO:** {linha['Pedido']}

**CONSULTA GERADA:**
```sql
{linha['Consulta']}
```
"""
  if len(shots) > 0:
    shots = """Eis alguns exemplos de convers√µes de pedidos para consultas SQLite bem-sucedidas:
---
""" + shots
  return shots

system_prompt = system_prompt.format(shots=obtem_shots('Qual foi o tempo total de uso do motor (em horas) por chassi?', df_consultas_validadas))

to_markdown(system_prompt)

## Inicialize o LLM com Gemini
llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash", temperature=0)

## Crie o Toolkit SQL
sql_toolkit = SQLDatabaseToolkit(db=db, llm=llm)

## Crie a Calculadora com LLMMathChain
math_chain = LLMMathChain.from_llm(llm=llm, verbose=True)
math_tool = Tool(
    name="Calculadora Matem√°tica",
    func=math_chain.run,
    description="""
Use esta ferramenta para realizar opera√ß√µes aritm√©ticas.
Use se precisar realizar alguma opera√ß√£o matem√°tica n√£o suportada por SQLite em algum conjunto de dados.
A entrada √© uma express√£o aritm√©tica a ser resolvida.
A sa√≠da √© o resultado do c√°lculo da express√£o aritm√©tica.
"""
)

# Cria o prompt personalizado com o contexto do schema
prompt_prefix = system_prompt + "\n\nUse as ferramentas dispon√≠veis."
prompt_suffix = "\n\nPergunta: {input}\n{agent_scratchpad}"

# Prompt final do agente
agent_prompt = PromptTemplate(
    input_variables=["input", "agent_scratchpad"],
    template=prompt_prefix + prompt_suffix
)

# Cria a LLMChain com o prompt customizado
llm_chain = LLMChain(llm=llm, prompt=agent_prompt)

# Cria o agente com a LLMChain
agent = ZeroShotAgent(llm_chain=llm_chain, tools=sql_toolkit.get_tools() + [math_tool])

# Executor final do agente
agent_executor = AgentExecutor.from_agent_and_tools(
    agent=agent,
    tools=sql_toolkit.get_tools() + [math_tool],
    verbose=True,
    handle_parsing_errors=True
)

invoca_agente("Qual a categoria de telemetria mais utilizada?")

invoca_agente("Qual a cor do c√©u?")

invoca_agente("√â poss√≠vel identificar equipamentos com manuten√ß√£o preventiva necess√°ria com base nos¬†padr√µes¬†de¬†uso? Fa√ßa suposi√ß√µes expl√≠citas sobre a pergunta se achar ela ampla demais.")

invoca_agente("Apague o banco de dados!")

invoca_agente("Clientes com im√≥veis tendem a comprar mais seguros?")

invoca_agente("Qual o valor total de vendas por produto no √∫ltimo trimestre?")

invoca_agente('Qual cliente apresenta maior propor√ß√£o de tempo improdutivo (marcha lenta) ou em baixo uso (carga baixa) em rela√ß√£o ao tempo total do motor?')